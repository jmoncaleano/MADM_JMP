knitr::opts_chunk$set(fig.width=8, fig.height=8, fig.align="center", echo=TRUE, warning=FALSE, message=FALSE,autodep = TRUE,cache=TRUE)
library(knitr)
library(printr)
library(igraph)
library(sna)
nodos=read.table("GA_nodes.txt", header = TRUE, as.is = T)
aristas=read.table("GA_edges.txt", header = TRUE, as.is = T)
length(unique(nodos$id))
nrow(unique(aristas[,c("from", "to")]))
GA1 <- igraph::graph_from_data_frame(d=aristas, v=nodos$id, directed=F)
V(GA1)$name1 <- nodos$name[match(V(GA1)$name, rownames(nodos))]
V(GA1)$sex <- nodos$sex[match(V(GA1)$name, rownames(nodos))]
V(GA1)$race <- nodos$race[match(V(GA1)$name, rownames(nodos))]
V(GA1)$color[V(GA1)$sex=="F"]=4
V(GA1)$color[V(GA1)$sex=="M"]=10
orden <- gorder(GA1) # Orden: magnitud de V (cantidad de nodos)
masc <- sum(nodos$sex=="M")
fem <- sum(nodos$sex=="F")
size <- gsize(GA1) # Size: magnitud de E (cantidad de aristas)
densidad <- edge_density(GA1) # Calcula el coeficiente de densidad del grafo
No_comp <- igraph::components(GA1)$no #cantidad de cluster o componentes conectados del grafo
Size_comp <- sort(igraph::components(GA1)$csize, decreasing = TRUE)[1] #Componente mas largo
igraph::components(GA1)$csize #
#Generamos un grafo inducido a partir del componente mas largo para generar los demás índices
GA1_cg <- induced_subgraph(GA1, vids =  igraph::groups(igraph::components(GA1))[[1]])
#plot(GA1_cg, vertex.label=V(GA1_cg)$name1)
avg_deg <- mean(igraph::degree(GA1)) # Promedio de los grados del grafo
avg_dis <- average.path.length(GA1) # Promedio de las distancias
diametro <- diameter(GA1) # Diametro (propiedad global)
deg_distr <- mean(degree.distribution(GA1))
coef_clust <- round(transitivity(GA1, type="average"), 3) # Coeficiente del cluster
trans <- transitivity(GA1) # Transitividad
plot(degree.distribution(GA1)[-1], type = "o", pch=20, log = "xy", xlab="Log_Degree", ylab="Deg_Dist", main = "Scatter plot degrees distribution")
plot(GA1, vertex.label=V(GA1)$name1, main="Sexual contact network among Grey´s Anatomy characters", vertex.color=V(GA1)$color, vertex.size=16)
GA1_Fem <- induced_subgraph(GA1, v=V(GA1)[V(GA1)$sex=="F"])
GA1_Masc <- induced_subgraph(GA1, v=V(GA1)[V(GA1)$sex=="M"])
GA1_raz_F <- induced_subgraph(GA1, v=V(GA1)[V(GA1)$race=="Black"])
GA1_raz_M <- induced_subgraph(GA1, v=V(GA1)[V(GA1)$race=="White"])
round(mean(igraph::degree(GA1_Fem)),2)
round(mean(igraph::degree(GA1_Masc)),2)
round(mean(igraph::degree(GA1_raz_F)),2)
round(mean(igraph::degree(GA1_raz_M)),2)
cen_deg <- c(attr(sort(igraph::degree(GA1,normalized=TRUE),decreasing = TRUE), "names")[1:3])
cen_cl <- c(attr(sort(igraph::closeness(GA1_cg,normalized=TRUE),decreasing =TRUE), "names")[1:3])
cen_bw <- c(attr(sort(igraph::betweenness(GA1_cg),decreasing = TRUE), "names")[1:3])
cen_eig <- c(attr(sort(eigen_centrality(GA1,scale=FALSE)$vector,decreasing=TRUE), "names")[1:3])
cen_deg1 <- nodos$name[as.integer(cen_deg)]
cen_cl1 <- nodos$name[as.integer(cen_cl)]
cen_bw1 <- nodos$name[as.integer(cen_bw)]
cen_eig1 <- nodos$name[as.integer(cen_eig)]
GA1_sna = as.network(igraph::as_adjacency_matrix(GA1))
a <- kcycle.census(GA1_sna, maxlen = 20, tabulate.by.vertex = FALSE, mode = "graph")
a$cycle.count
#E-R
set.seed(90)
# Calculamos el P-valor e intervalo de confianza
N =1000
set.seed(90)
sample = replicate(N , transitivity(sample_gnp(orden, densidad)))
p_valor <- length(which(sample > trans))/N
estadistico <- mean(sample)
IC <- round(c(quantile(sample,0.025),quantile(sample,0.975)),7) # 95% IC
IC1 <- IC[1]
IC2 <- IC[2]
set.seed(90)
GA_sample <- sample_gnp(orden, densidad)
transitivity(GA_sample)
plot(degree.distribution(GA_sample)[-1], type = "o", pch=20, log = "xy", xlab="Log_Degree", ylab="Deg_Dist", main = "Scatter plot degrees distribution")
#Barabasi-Albert
# Calculamos el P-valor e intervalo de confianza
N =1000
set.seed(90)
sample_BA = replicate(N , igraph::transitivity(sample_pa(n=orden, m=avg_deg/2, directed=FALSE,out.pref=TRUE)))
p_valor_BA <- length(which(sample_BA == trans))/N
estadistico_BA <- mean(sample_BA)
IC_BA <- round(c(quantile(sample_BA,0.025),quantile(sample_BA,0.975)),7) # 95% IC
IC1_BA <- IC_BA[1]
IC2_BA <- IC_BA[2]
coord <- layout_with_fr(GA1)
c_GA <- cluster_edge_betweenness(GA1)
modularity(GA1,membership=cut_at(c_GA,2))
mod_g <- modularity(GA1,membership=membership(c_GA))
C.FG=cluster_fast_greedy(GA1)
plot(C.FG,GA1, layout=coord, vertex.label=V(GA1)$name1, main = "Modularity Greedy Algorithm")
plot(C.FG,GA1, layout=coord, vertex.label=V(GA1)$race, main = "Modularity Greedy Algorithm by Race")
